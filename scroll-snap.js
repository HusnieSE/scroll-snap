!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define([],I):"object"==typeof exports?exports["scroll-snap"]=I():g["scroll-snap"]=I()}(window,function(){return function(g){var I={};function n(C){if(I[C])return I[C].exports;var t=I[C]={i:C,l:!1,exports:{}};return g[C].call(t.exports,t,t.exports,n),t.l=!0,t.exports}return n.m=g,n.c=I,n.d=function(g,I,C){n.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:C})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,I){if(1&I&&(g=n(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var C=Object.create(null);if(n.r(C),Object.defineProperty(C,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)n.d(C,t,function(I){return g[I]}.bind(null,t));return C},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p="",n(n.s=0)}([function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar index_1 = __webpack_require__(1);\nfunction callback() {\n    console.log('snap');\n}\nvar containerVertical = document.getElementById('container');\nvar snapVertical = new index_1.default(containerVertical, {\n    snapDestinationY: '90%',\n    timeout: 100,\n    duration: 300,\n    easing: function (t) { return (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t); },\n}).bind(callback);\nvar containerHorizontal = document.getElementById('container-horizontal');\nvar snapHorizontal = new index_1.default(containerHorizontal, {\n    snapDestinationX: '90%',\n    timeout: 100,\n    duration: 300,\n    easing: function (t) { return (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t); },\n}).bind(callback);\nwindow.unbind = function () {\n    snapVertical.unbind();\n    snapHorizontal.unbind();\n};\nwindow.bind = function () {\n    snapVertical.bind(callback);\n    snapHorizontal.bind(callback);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zY3JvbGwtc25hcC8uL2RlbW8vc3JjL2luZGV4LnRzP2U3NzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsQ0FBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQsRUFBRTtBQUNqRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQsRUFBRTtBQUNqRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9zcmMvaW5kZXhcIik7XG5mdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICBjb25zb2xlLmxvZygnc25hcCcpO1xufVxudmFyIGNvbnRhaW5lclZlcnRpY2FsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpO1xudmFyIHNuYXBWZXJ0aWNhbCA9IG5ldyBpbmRleF8xLmRlZmF1bHQoY29udGFpbmVyVmVydGljYWwsIHtcbiAgICBzbmFwRGVzdGluYXRpb25ZOiAnOTAlJyxcbiAgICB0aW1lb3V0OiAxMDAsXG4gICAgZHVyYXRpb246IDMwMCxcbiAgICBlYXNpbmc6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAodCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0KTsgfSxcbn0pLmJpbmQoY2FsbGJhY2spO1xudmFyIGNvbnRhaW5lckhvcml6b250YWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWhvcml6b250YWwnKTtcbnZhciBzbmFwSG9yaXpvbnRhbCA9IG5ldyBpbmRleF8xLmRlZmF1bHQoY29udGFpbmVySG9yaXpvbnRhbCwge1xuICAgIHNuYXBEZXN0aW5hdGlvblg6ICc5MCUnLFxuICAgIHRpbWVvdXQ6IDEwMCxcbiAgICBkdXJhdGlvbjogMzAwLFxuICAgIGVhc2luZzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuICh0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQpOyB9LFxufSkuYmluZChjYWxsYmFjayk7XG53aW5kb3cudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHNuYXBWZXJ0aWNhbC51bmJpbmQoKTtcbiAgICBzbmFwSG9yaXpvbnRhbC51bmJpbmQoKTtcbn07XG53aW5kb3cuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzbmFwVmVydGljYWwuYmluZChjYWxsYmFjayk7XG4gICAgc25hcEhvcml6b250YWwuYmluZChjYWxsYmFjayk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\nvar TIMEOUT_DEFAULT = 100;\nvar DURATION_DEFAULT = 300;\nvar EASING_DEFAULT = easeInOutQuad;\nvar NOOP = function () { };\nvar ScrollSnap = /** @class */ (function () {\n    function ScrollSnap(element, config) {\n        var _this = this;\n        this.animating = false;\n        this.lastScrollValue = {\n            x: 0,\n            y: 0,\n        };\n        this.startAnimation = function () {\n            _this.speedDeltaX = _this.checkScrollSpeed(_this.target.scrollLeft, 'x');\n            _this.speedDeltaY = _this.checkScrollSpeed(_this.target.scrollTop, 'y');\n            if (_this.animating || (_this.speedDeltaX === 0 && _this.speedDeltaY === 0)) {\n                return;\n            }\n            _this.handler(_this.target);\n        };\n        this.animationHandler = function () {\n            // if we don't move a thing, we can ignore the timeout: if we did, there'd be another timeout added for this.scrollStart+1.\n            if (_this.scrollStart.y === _this.target.scrollTop &&\n                _this.scrollStart.x === _this.target.scrollLeft) {\n                // ignore timeout\n                return;\n            }\n            // detect direction of scroll. negative is up, positive is down.\n            var direction = {\n                y: _this.speedDeltaY > 0 ? 1 : -1,\n                x: _this.speedDeltaX > 0 ? 1 : -1,\n            };\n            // get the next snap-point to snap-to\n            var snapPoint = _this.getNextSnapPoint(_this.target, direction);\n            _this.listenerElement.removeEventListener('scroll', _this.startAnimation, false);\n            _this.animating = true;\n            // smoothly move to the snap point\n            _this.smoothScroll(_this.target, snapPoint, function () {\n                // after moving to the snap point, rebind the scroll event handler\n                _this.animating = false;\n                _this.listenerElement.addEventListener('scroll', _this.startAnimation, false);\n                _this.onAnimationEnd();\n            });\n            // we just jumped to the snapPoint, so this will be our next this.scrollStart\n            if (!isNaN(snapPoint.x) || !isNaN(snapPoint.y)) {\n                _this.scrollStart = snapPoint;\n            }\n        };\n        this.element = element;\n        if (config.timeout && (isNaN(config.timeout) || typeof config.timeout === 'boolean')) {\n            throw new Error(\"Optional config property 'timeout' is not valid, expected NUMBER but found \" + (typeof config.timeout).toUpperCase());\n        }\n        this.timeout = config.timeout || TIMEOUT_DEFAULT;\n        if (config.duration && (isNaN(config.duration) || typeof config.duration === 'boolean')) {\n            throw new Error(\"Optional config property 'duration' is not valid, expected NUMBER but found \" + (typeof config.duration).toUpperCase());\n        }\n        this.duration = config.duration || DURATION_DEFAULT;\n        if (config.easing && typeof config.easing !== 'function') {\n            throw new Error(\"Optional config property 'easing' is not valid, expected FUNCTION but found \" + (typeof config.easing).toUpperCase());\n        }\n        this.easing = config.easing || EASING_DEFAULT;\n        if (config.snapDestinationX && typeof config.snapDestinationX !== 'string') {\n            throw new Error(\"Optional config property 'snapDestinationX' is not valid, expected STRING but found \" + (typeof config.easing).toUpperCase());\n        }\n        this.snapDestinationX = config.snapDestinationX;\n        if (config.snapDestinationY && typeof config.snapDestinationY !== 'string') {\n            throw new Error(\"Optional config property 'snapDestinationY' is not valid, expected STRING but found \" + (typeof config.easing).toUpperCase());\n        }\n        this.snapDestinationY = config.snapDestinationY;\n    }\n    ScrollSnap.prototype.checkScrollSpeed = function (value, axis) {\n        var _this = this;\n        var clear = function () {\n            _this.lastScrollValue[axis] = null;\n        };\n        var newValue = value;\n        var delta;\n        if (this.lastScrollValue[axis] !== null) {\n            delta = newValue - this.lastScrollValue[axis];\n        }\n        else {\n            delta = 0;\n        }\n        this.lastScrollValue[axis] = newValue;\n        this.scrollSpeedTimer && clearTimeout(this.scrollSpeedTimer);\n        this.scrollSpeedTimer = setTimeout(clear, 100);\n        return delta;\n    };\n    ScrollSnap.prototype.saveDeclaration = function (obj) {\n        this.snapLengthUnit = this.parseSnapCoordValue(this.snapDestinationX, this.snapDestinationY);\n    };\n    ScrollSnap.prototype.bindElement = function (element) {\n        this.target = element;\n        this.listenerElement = element === document.documentElement ? window : element;\n        this.listenerElement.addEventListener('scroll', this.startAnimation, false);\n        this.saveDeclaration(this.target);\n    };\n    ScrollSnap.prototype.unbindElement = function () {\n        this.listenerElement.removeEventListener('scroll', this.startAnimation, false);\n    };\n    /**\n     * scroll handler\n     * this is the callback for scroll events.\n     */\n    ScrollSnap.prototype.handler = function (target) {\n        // if currently this.animating, stop it. this prevents flickering.\n        if (this.animationFrame) {\n            clearTimeout(this.animationFrame);\n        }\n        // if a previous timeout exists, clear it.\n        if (this.scrollHandlerTimer) {\n            // we only want to call a timeout once after scrolling..\n            clearTimeout(this.scrollHandlerTimer);\n        }\n        else {\n            this.scrollStart = {\n                y: target.scrollTop,\n                x: target.scrollLeft,\n            };\n        }\n        this.scrollHandlerTimer = setTimeout(this.animationHandler, this.timeout);\n    };\n    ScrollSnap.prototype.getNextSnapPoint = function (target, direction) {\n        // get snap length\n        var snapLength = {\n            y: Math.round(this.getYSnapLength(this.target, this.snapLengthUnit.y)),\n            x: Math.round(this.getXSnapLength(this.target, this.snapLengthUnit.x)),\n        };\n        var top = this.target.scrollTop;\n        var left = this.target.scrollLeft;\n        // calc current and initial snappoint\n        var currentPoint = {\n            y: top / snapLength.y || 1,\n            x: left / snapLength.x || 1,\n        };\n        var nextPoint = {\n            y: 0,\n            x: 0,\n        };\n        // set target and bounds by direction\n        nextPoint.y = this.roundByDirection(direction.y, currentPoint.y);\n        nextPoint.x = this.roundByDirection(direction.x, currentPoint.x);\n        // calculate where to scroll\n        var scrollTo = {\n            y: nextPoint.y * snapLength.y,\n            x: nextPoint.x * snapLength.x,\n        };\n        // stay in bounds (minimum: 0, maxmimum: absolute height)\n        scrollTo.y = this.stayInBounds(0, target.scrollHeight, scrollTo.y);\n        scrollTo.x = this.stayInBounds(0, target.scrollWidth, scrollTo.x);\n        return scrollTo;\n    };\n    ScrollSnap.prototype.roundByDirection = function (direction, currentPoint) {\n        if (direction === -1) {\n            // when we go up, we floor the number to jump to the next snap-point in scroll direction\n            return Math.floor(currentPoint);\n        }\n        // go down, we ceil the number to jump to the next in view.\n        return Math.ceil(currentPoint);\n    };\n    ScrollSnap.prototype.stayInBounds = function (min, max, destined) {\n        return Math.max(Math.min(destined, max), min);\n    };\n    ScrollSnap.prototype.parseSnapCoordValue = function (x, y) {\n        // regex to parse lengths\n        var regex = /(\\d+)(px|%|vw|vh)/;\n        // defaults\n        var parsed = {\n            y: {\n                value: 0,\n                unit: 'px',\n            },\n            x: {\n                value: 0,\n                unit: 'px',\n            },\n        };\n        // parse value and unit\n        var resultX = regex.exec(x);\n        var resultY = regex.exec(y);\n        // if regexp fails, value is null\n        if (resultX !== null) {\n            parsed.x = {\n                value: Number(resultX[1]),\n                unit: resultX[2],\n            };\n        }\n        if (resultY !== null) {\n            parsed.y = {\n                value: Number(resultY[1]),\n                unit: resultY[2],\n            };\n        }\n        return parsed;\n    };\n    ScrollSnap.prototype.getYSnapLength = function (obj, declaration) {\n        if (declaration.unit === 'vh') {\n            // when using vh, one snap is the length of vh / 100 * value\n            return ((Math.max(document.documentElement.clientHeight, window.innerHeight || 1) / 100) *\n                declaration.value);\n        }\n        else if (declaration.unit === '%') {\n            // when using %, one snap is the length of element height / 100 * value\n            return (obj.clientHeight / 100) * declaration.value;\n        }\n        else {\n            // when using px, one snap is the length of element height / value\n            return obj.clientHeight / declaration.value;\n        }\n    };\n    ScrollSnap.prototype.getXSnapLength = function (obj, declaration) {\n        if (declaration.unit === 'vw') {\n            // when using vw, one snap is the length of vw / 100 * value\n            return ((Math.max(document.documentElement.clientWidth, window.innerWidth || 1) / 100) *\n                declaration.value);\n        }\n        else if (declaration.unit === '%') {\n            // when using %, one snap is the length of element width / 100 * value\n            return (obj.clientWidth / 100) * declaration.value;\n        }\n        else {\n            // when using px, one snap is the length of element width / value\n            return obj.clientWidth / declaration.value;\n        }\n    };\n    ScrollSnap.prototype.isEdge = function (coords) {\n        return (coords.x === 0 && this.speedDeltaY === 0) || (coords.y === 0 && this.speedDeltaX === 0);\n    };\n    ScrollSnap.prototype.smoothScroll = function (obj, end, callback) {\n        var _this = this;\n        var position = function (start, end, elapsed, duration) {\n            if (elapsed > duration) {\n                return end;\n            }\n            return start + (end - start) * _this.easing(elapsed / duration);\n        };\n        var start = {\n            y: obj.scrollTop,\n            x: obj.scrollLeft,\n        };\n        // get animation frame or a fallback\n        var requestAnimationFrame = window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            function (fn) {\n                return window.setTimeout(fn, 15);\n            };\n        var duration = this.isEdge(start) ? 0 : this.duration;\n        var startTime;\n        // setup the stepping function\n        function step(timestamp) {\n            if (!startTime) {\n                startTime = timestamp;\n            }\n            var elapsed = timestamp - startTime;\n            // change position on y-axis if result is a number.\n            if (!isNaN(end.y)) {\n                obj.scrollTop = position(start.y, end.y, elapsed, duration);\n            }\n            // change position on x-axis if result is a number.\n            if (!isNaN(end.x)) {\n                obj.scrollLeft = position(start.x, end.x, elapsed, duration);\n            }\n            // check if we are over due;\n            if (elapsed < duration) {\n                requestAnimationFrame(step);\n            }\n            else {\n                // is there a callback?\n                if (typeof callback === 'function') {\n                    // stop execution and run the callback\n                    return callback(end);\n                }\n            }\n        }\n        this.animationFrame = requestAnimationFrame(step);\n    };\n    ScrollSnap.prototype.bind = function (callback) {\n        this.onAnimationEnd = typeof callback === 'function' ? callback : NOOP;\n        this.bindElement(this.element);\n        return this;\n    };\n    ScrollSnap.prototype.unbind = function () {\n        this.unbindElement();\n        return this;\n    };\n    return ScrollSnap;\n}());\nexports.default = ScrollSnap;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zY3JvbGwtc25hcC8uL3NyYy9pbmRleC50cz83MWJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBlYXNlSW5PdXRRdWFkKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xufVxudmFyIFRJTUVPVVRfREVGQVVMVCA9IDEwMDtcbnZhciBEVVJBVElPTl9ERUZBVUxUID0gMzAwO1xudmFyIEVBU0lOR19ERUZBVUxUID0gZWFzZUluT3V0UXVhZDtcbnZhciBOT09QID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIFNjcm9sbFNuYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nyb2xsU25hcChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVmFsdWUgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNwZWVkRGVsdGFYID0gX3RoaXMuY2hlY2tTY3JvbGxTcGVlZChfdGhpcy50YXJnZXQuc2Nyb2xsTGVmdCwgJ3gnKTtcbiAgICAgICAgICAgIF90aGlzLnNwZWVkRGVsdGFZID0gX3RoaXMuY2hlY2tTY3JvbGxTcGVlZChfdGhpcy50YXJnZXQuc2Nyb2xsVG9wLCAneScpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmFuaW1hdGluZyB8fCAoX3RoaXMuc3BlZWREZWx0YVggPT09IDAgJiYgX3RoaXMuc3BlZWREZWx0YVkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlcihfdGhpcy50YXJnZXQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBtb3ZlIGEgdGhpbmcsIHdlIGNhbiBpZ25vcmUgdGhlIHRpbWVvdXQ6IGlmIHdlIGRpZCwgdGhlcmUnZCBiZSBhbm90aGVyIHRpbWVvdXQgYWRkZWQgZm9yIHRoaXMuc2Nyb2xsU3RhcnQrMS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5zY3JvbGxTdGFydC55ID09PSBfdGhpcy50YXJnZXQuc2Nyb2xsVG9wICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsU3RhcnQueCA9PT0gX3RoaXMudGFyZ2V0LnNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGltZW91dFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRldGVjdCBkaXJlY3Rpb24gb2Ygc2Nyb2xsLiBuZWdhdGl2ZSBpcyB1cCwgcG9zaXRpdmUgaXMgZG93bi5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogX3RoaXMuc3BlZWREZWx0YVkgPiAwID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgIHg6IF90aGlzLnNwZWVkRGVsdGFYID4gMCA/IDEgOiAtMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBnZXQgdGhlIG5leHQgc25hcC1wb2ludCB0byBzbmFwLXRvXG4gICAgICAgICAgICB2YXIgc25hcFBvaW50ID0gX3RoaXMuZ2V0TmV4dFNuYXBQb2ludChfdGhpcy50YXJnZXQsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICBfdGhpcy5saXN0ZW5lckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuc3RhcnRBbmltYXRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgIF90aGlzLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgICAvLyBzbW9vdGhseSBtb3ZlIHRvIHRoZSBzbmFwIHBvaW50XG4gICAgICAgICAgICBfdGhpcy5zbW9vdGhTY3JvbGwoX3RoaXMudGFyZ2V0LCBzbmFwUG9pbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBhZnRlciBtb3ZpbmcgdG8gdGhlIHNuYXAgcG9pbnQsIHJlYmluZCB0aGUgc2Nyb2xsIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5saXN0ZW5lckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuc3RhcnRBbmltYXRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkFuaW1hdGlvbkVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBqdXN0IGp1bXBlZCB0byB0aGUgc25hcFBvaW50LCBzbyB0aGlzIHdpbGwgYmUgb3VyIG5leHQgdGhpcy5zY3JvbGxTdGFydFxuICAgICAgICAgICAgaWYgKCFpc05hTihzbmFwUG9pbnQueCkgfHwgIWlzTmFOKHNuYXBQb2ludC55KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbFN0YXJ0ID0gc25hcFBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXQgJiYgKGlzTmFOKGNvbmZpZy50aW1lb3V0KSB8fCB0eXBlb2YgY29uZmlnLnRpbWVvdXQgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbmFsIGNvbmZpZyBwcm9wZXJ0eSAndGltZW91dCcgaXMgbm90IHZhbGlkLCBleHBlY3RlZCBOVU1CRVIgYnV0IGZvdW5kIFwiICsgKHR5cGVvZiBjb25maWcudGltZW91dCkudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQgfHwgVElNRU9VVF9ERUZBVUxUO1xuICAgICAgICBpZiAoY29uZmlnLmR1cmF0aW9uICYmIChpc05hTihjb25maWcuZHVyYXRpb24pIHx8IHR5cGVvZiBjb25maWcuZHVyYXRpb24gPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbmFsIGNvbmZpZyBwcm9wZXJ0eSAnZHVyYXRpb24nIGlzIG5vdCB2YWxpZCwgZXhwZWN0ZWQgTlVNQkVSIGJ1dCBmb3VuZCBcIiArICh0eXBlb2YgY29uZmlnLmR1cmF0aW9uKS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uIHx8IERVUkFUSU9OX0RFRkFVTFQ7XG4gICAgICAgIGlmIChjb25maWcuZWFzaW5nICYmIHR5cGVvZiBjb25maWcuZWFzaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb25hbCBjb25maWcgcHJvcGVydHkgJ2Vhc2luZycgaXMgbm90IHZhbGlkLCBleHBlY3RlZCBGVU5DVElPTiBidXQgZm91bmQgXCIgKyAodHlwZW9mIGNvbmZpZy5lYXNpbmcpLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWFzaW5nID0gY29uZmlnLmVhc2luZyB8fCBFQVNJTkdfREVGQVVMVDtcbiAgICAgICAgaWYgKGNvbmZpZy5zbmFwRGVzdGluYXRpb25YICYmIHR5cGVvZiBjb25maWcuc25hcERlc3RpbmF0aW9uWCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbmFsIGNvbmZpZyBwcm9wZXJ0eSAnc25hcERlc3RpbmF0aW9uWCcgaXMgbm90IHZhbGlkLCBleHBlY3RlZCBTVFJJTkcgYnV0IGZvdW5kIFwiICsgKHR5cGVvZiBjb25maWcuZWFzaW5nKS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNuYXBEZXN0aW5hdGlvblggPSBjb25maWcuc25hcERlc3RpbmF0aW9uWDtcbiAgICAgICAgaWYgKGNvbmZpZy5zbmFwRGVzdGluYXRpb25ZICYmIHR5cGVvZiBjb25maWcuc25hcERlc3RpbmF0aW9uWSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbmFsIGNvbmZpZyBwcm9wZXJ0eSAnc25hcERlc3RpbmF0aW9uWScgaXMgbm90IHZhbGlkLCBleHBlY3RlZCBTVFJJTkcgYnV0IGZvdW5kIFwiICsgKHR5cGVvZiBjb25maWcuZWFzaW5nKS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNuYXBEZXN0aW5hdGlvblkgPSBjb25maWcuc25hcERlc3RpbmF0aW9uWTtcbiAgICB9XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuY2hlY2tTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXN0U2Nyb2xsVmFsdWVbYXhpc10gPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICBpZiAodGhpcy5sYXN0U2Nyb2xsVmFsdWVbYXhpc10gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbHRhID0gbmV3VmFsdWUgLSB0aGlzLmxhc3RTY3JvbGxWYWx1ZVtheGlzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RTY3JvbGxWYWx1ZVtheGlzXSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkVGltZXIgJiYgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsU3BlZWRUaW1lcik7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWRUaW1lciA9IHNldFRpbWVvdXQoY2xlYXIsIDEwMCk7XG4gICAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLnNhdmVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdGhpcy5zbmFwTGVuZ3RoVW5pdCA9IHRoaXMucGFyc2VTbmFwQ29vcmRWYWx1ZSh0aGlzLnNuYXBEZXN0aW5hdGlvblgsIHRoaXMuc25hcERlc3RpbmF0aW9uWSk7XG4gICAgfTtcbiAgICBTY3JvbGxTbmFwLnByb3RvdHlwZS5iaW5kRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5saXN0ZW5lckVsZW1lbnQgPSBlbGVtZW50ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyB3aW5kb3cgOiBlbGVtZW50O1xuICAgICAgICB0aGlzLmxpc3RlbmVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnN0YXJ0QW5pbWF0aW9uLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2F2ZURlY2xhcmF0aW9uKHRoaXMudGFyZ2V0KTtcbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLnVuYmluZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuc3RhcnRBbmltYXRpb24sIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNjcm9sbCBoYW5kbGVyXG4gICAgICogdGhpcyBpcyB0aGUgY2FsbGJhY2sgZm9yIHNjcm9sbCBldmVudHMuXG4gICAgICovXG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgLy8gaWYgY3VycmVudGx5IHRoaXMuYW5pbWF0aW5nLCBzdG9wIGl0LiB0aGlzIHByZXZlbnRzIGZsaWNrZXJpbmcuXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltYXRpb25GcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYSBwcmV2aW91cyB0aW1lb3V0IGV4aXN0cywgY2xlYXIgaXQuXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEhhbmRsZXJUaW1lcikge1xuICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIGNhbGwgYSB0aW1lb3V0IG9uY2UgYWZ0ZXIgc2Nyb2xsaW5nLi5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbEhhbmRsZXJUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIHk6IHRhcmdldC5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlclRpbWVyID0gc2V0VGltZW91dCh0aGlzLmFuaW1hdGlvbkhhbmRsZXIsIHRoaXMudGltZW91dCk7XG4gICAgfTtcbiAgICBTY3JvbGxTbmFwLnByb3RvdHlwZS5nZXROZXh0U25hcFBvaW50ID0gZnVuY3Rpb24gKHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIC8vIGdldCBzbmFwIGxlbmd0aFxuICAgICAgICB2YXIgc25hcExlbmd0aCA9IHtcbiAgICAgICAgICAgIHk6IE1hdGgucm91bmQodGhpcy5nZXRZU25hcExlbmd0aCh0aGlzLnRhcmdldCwgdGhpcy5zbmFwTGVuZ3RoVW5pdC55KSksXG4gICAgICAgICAgICB4OiBNYXRoLnJvdW5kKHRoaXMuZ2V0WFNuYXBMZW5ndGgodGhpcy50YXJnZXQsIHRoaXMuc25hcExlbmd0aFVuaXQueCkpLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdG9wID0gdGhpcy50YXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMudGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICAgIC8vIGNhbGMgY3VycmVudCBhbmQgaW5pdGlhbCBzbmFwcG9pbnRcbiAgICAgICAgdmFyIGN1cnJlbnRQb2ludCA9IHtcbiAgICAgICAgICAgIHk6IHRvcCAvIHNuYXBMZW5ndGgueSB8fCAxLFxuICAgICAgICAgICAgeDogbGVmdCAvIHNuYXBMZW5ndGgueCB8fCAxLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbmV4dFBvaW50ID0ge1xuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgIH07XG4gICAgICAgIC8vIHNldCB0YXJnZXQgYW5kIGJvdW5kcyBieSBkaXJlY3Rpb25cbiAgICAgICAgbmV4dFBvaW50LnkgPSB0aGlzLnJvdW5kQnlEaXJlY3Rpb24oZGlyZWN0aW9uLnksIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgbmV4dFBvaW50LnggPSB0aGlzLnJvdW5kQnlEaXJlY3Rpb24oZGlyZWN0aW9uLngsIGN1cnJlbnRQb2ludC54KTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHdoZXJlIHRvIHNjcm9sbFxuICAgICAgICB2YXIgc2Nyb2xsVG8gPSB7XG4gICAgICAgICAgICB5OiBuZXh0UG9pbnQueSAqIHNuYXBMZW5ndGgueSxcbiAgICAgICAgICAgIHg6IG5leHRQb2ludC54ICogc25hcExlbmd0aC54LFxuICAgICAgICB9O1xuICAgICAgICAvLyBzdGF5IGluIGJvdW5kcyAobWluaW11bTogMCwgbWF4bWltdW06IGFic29sdXRlIGhlaWdodClcbiAgICAgICAgc2Nyb2xsVG8ueSA9IHRoaXMuc3RheUluQm91bmRzKDAsIHRhcmdldC5zY3JvbGxIZWlnaHQsIHNjcm9sbFRvLnkpO1xuICAgICAgICBzY3JvbGxUby54ID0gdGhpcy5zdGF5SW5Cb3VuZHMoMCwgdGFyZ2V0LnNjcm9sbFdpZHRoLCBzY3JvbGxUby54KTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbFRvO1xuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUucm91bmRCeURpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIGN1cnJlbnRQb2ludCkge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgLy8gd2hlbiB3ZSBnbyB1cCwgd2UgZmxvb3IgdGhlIG51bWJlciB0byBqdW1wIHRvIHRoZSBuZXh0IHNuYXAtcG9pbnQgaW4gc2Nyb2xsIGRpcmVjdGlvblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY3VycmVudFBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnbyBkb3duLCB3ZSBjZWlsIHRoZSBudW1iZXIgdG8ganVtcCB0byB0aGUgbmV4dCBpbiB2aWV3LlxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGN1cnJlbnRQb2ludCk7XG4gICAgfTtcbiAgICBTY3JvbGxTbmFwLnByb3RvdHlwZS5zdGF5SW5Cb3VuZHMgPSBmdW5jdGlvbiAobWluLCBtYXgsIGRlc3RpbmVkKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihkZXN0aW5lZCwgbWF4KSwgbWluKTtcbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLnBhcnNlU25hcENvb3JkVmFsdWUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAvLyByZWdleCB0byBwYXJzZSBsZW5ndGhzXG4gICAgICAgIHZhciByZWdleCA9IC8oXFxkKykocHh8JXx2d3x2aCkvO1xuICAgICAgICAvLyBkZWZhdWx0c1xuICAgICAgICB2YXIgcGFyc2VkID0ge1xuICAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIHVuaXQ6ICdweCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIHVuaXQ6ICdweCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBwYXJzZSB2YWx1ZSBhbmQgdW5pdFxuICAgICAgICB2YXIgcmVzdWx0WCA9IHJlZ2V4LmV4ZWMoeCk7XG4gICAgICAgIHZhciByZXN1bHRZID0gcmVnZXguZXhlYyh5KTtcbiAgICAgICAgLy8gaWYgcmVnZXhwIGZhaWxzLCB2YWx1ZSBpcyBudWxsXG4gICAgICAgIGlmIChyZXN1bHRYICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJzZWQueCA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogTnVtYmVyKHJlc3VsdFhbMV0pLFxuICAgICAgICAgICAgICAgIHVuaXQ6IHJlc3VsdFhbMl0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRZICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJzZWQueSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogTnVtYmVyKHJlc3VsdFlbMV0pLFxuICAgICAgICAgICAgICAgIHVuaXQ6IHJlc3VsdFlbMl0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfTtcbiAgICBTY3JvbGxTbmFwLnByb3RvdHlwZS5nZXRZU25hcExlbmd0aCA9IGZ1bmN0aW9uIChvYmosIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbi51bml0ID09PSAndmgnKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHVzaW5nIHZoLCBvbmUgc25hcCBpcyB0aGUgbGVuZ3RoIG9mIHZoIC8gMTAwICogdmFsdWVcbiAgICAgICAgICAgIHJldHVybiAoKE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAxKSAvIDEwMCkgKlxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbi51bml0ID09PSAnJScpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgJSwgb25lIHNuYXAgaXMgdGhlIGxlbmd0aCBvZiBlbGVtZW50IGhlaWdodCAvIDEwMCAqIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gKG9iai5jbGllbnRIZWlnaHQgLyAxMDApICogZGVjbGFyYXRpb24udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3aGVuIHVzaW5nIHB4LCBvbmUgc25hcCBpcyB0aGUgbGVuZ3RoIG9mIGVsZW1lbnQgaGVpZ2h0IC8gdmFsdWVcbiAgICAgICAgICAgIHJldHVybiBvYmouY2xpZW50SGVpZ2h0IC8gZGVjbGFyYXRpb24udmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLmdldFhTbmFwTGVuZ3RoID0gZnVuY3Rpb24gKG9iaiwgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnVuaXQgPT09ICd2dycpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgdncsIG9uZSBzbmFwIGlzIHRoZSBsZW5ndGggb2YgdncgLyAxMDAgKiB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuICgoTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAxKSAvIDEwMCkgKlxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbi51bml0ID09PSAnJScpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgJSwgb25lIHNuYXAgaXMgdGhlIGxlbmd0aCBvZiBlbGVtZW50IHdpZHRoIC8gMTAwICogdmFsdWVcbiAgICAgICAgICAgIHJldHVybiAob2JqLmNsaWVudFdpZHRoIC8gMTAwKSAqIGRlY2xhcmF0aW9uLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2hlbiB1c2luZyBweCwgb25lIHNuYXAgaXMgdGhlIGxlbmd0aCBvZiBlbGVtZW50IHdpZHRoIC8gdmFsdWVcbiAgICAgICAgICAgIHJldHVybiBvYmouY2xpZW50V2lkdGggLyBkZWNsYXJhdGlvbi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuaXNFZGdlID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gKGNvb3Jkcy54ID09PSAwICYmIHRoaXMuc3BlZWREZWx0YVkgPT09IDApIHx8IChjb29yZHMueSA9PT0gMCAmJiB0aGlzLnNwZWVkRGVsdGFYID09PSAwKTtcbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLnNtb290aFNjcm9sbCA9IGZ1bmN0aW9uIChvYmosIGVuZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGVsYXBzZWQsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBfdGhpcy5lYXNpbmcoZWxhcHNlZCAvIGR1cmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0YXJ0ID0ge1xuICAgICAgICAgICAgeTogb2JqLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHg6IG9iai5zY3JvbGxMZWZ0LFxuICAgICAgICB9O1xuICAgICAgICAvLyBnZXQgYW5pbWF0aW9uIGZyYW1lIG9yIGEgZmFsbGJhY2tcbiAgICAgICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgMTUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5pc0VkZ2Uoc3RhcnQpID8gMCA6IHRoaXMuZHVyYXRpb247XG4gICAgICAgIHZhciBzdGFydFRpbWU7XG4gICAgICAgIC8vIHNldHVwIHRoZSBzdGVwcGluZyBmdW5jdGlvblxuICAgICAgICBmdW5jdGlvbiBzdGVwKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgaWYgKCFzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWxhcHNlZCA9IHRpbWVzdGFtcCAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIC8vIGNoYW5nZSBwb3NpdGlvbiBvbiB5LWF4aXMgaWYgcmVzdWx0IGlzIGEgbnVtYmVyLlxuICAgICAgICAgICAgaWYgKCFpc05hTihlbmQueSkpIHtcbiAgICAgICAgICAgICAgICBvYmouc2Nyb2xsVG9wID0gcG9zaXRpb24oc3RhcnQueSwgZW5kLnksIGVsYXBzZWQsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoYW5nZSBwb3NpdGlvbiBvbiB4LWF4aXMgaWYgcmVzdWx0IGlzIGEgbnVtYmVyLlxuICAgICAgICAgICAgaWYgKCFpc05hTihlbmQueCkpIHtcbiAgICAgICAgICAgICAgICBvYmouc2Nyb2xsTGVmdCA9IHBvc2l0aW9uKHN0YXJ0LngsIGVuZC54LCBlbGFwc2VkLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgb3ZlciBkdWU7XG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgYSBjYWxsYmFjaz9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgZXhlY3V0aW9uIGFuZCBydW4gdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uQW5pbWF0aW9uRW5kID0gdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBOT09QO1xuICAgICAgICB0aGlzLmJpbmRFbGVtZW50KHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuYmluZEVsZW1lbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsU25hcDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxTbmFwO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")}])});